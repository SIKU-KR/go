## 제로 값
Go는 선언되었지만 값이 할당되지 않은 모든 변수에 대해 기본값인 제로값(zero-value)를 할당한다. 그러나 명시적으로 제로 값을 넣어주는 것이 코드를 더 명확하게 하고 버그들을 제거할 수 있다.

## 리터럴
Go 에서 리터럴은 숫자, 문자, 혹은 문자열을 쓰는 것을 나타낸다. 주로 4개의 리터럴을 사용한다.

1. 정수 (Integer) 리터럴은 일련의 숫자이다. 
   1. 일반적으로 10진수를 의미하지만 접두사 (0b, 0o, 0x)를 붙여 다른 진법도 사용가능하다. 
   2. 긴 정수 리터럴을 읽기 쉽게 만들기 위해 정수 리터럴 사이에 _를 넣는것을 허용한다. (`1_000`)
2. 부동소수점 (floating point) 리터럴은 소수부를 구분하는 소수점이 있다. 또한 문자 e와 양수 혹은 음수로 지정된 지수를 가질 수 있다.
3. 룬(rune) 리터럴은 문자를 나타내며 작은 따옴표로 묶어 사용한다. Go는 작은 따옴표와 큰따옴표는 혼용할 수 없다. 
   1. `'a'`, `'\141'`, `'\x61'`, `'\u006'` 이런식으로 사용가능하고, 
   2. `'\n'`(줄바꿈), `'\t'`(탭), `'\''`(작은따옴표), `'\"'`(큰따옴표)를 많이 쓴다.
4. 문자열(String) 리터럴은 두가지가 있다.
   1. 해석된 문자열 리터럴로 큰따옴표를 사용해서 만들 수 있다. `"Hello World"` 이는 허용된 모든 형식의 룬 리터럴이 0개 이상 포함된다.
   2. 문자열에서 역슬래시, 큰따옴표 혹은 줄 바꿈을 그대로 포함하여 출력하고자 한다면 로우 문자열(raw string) 리터럴을 사용해야한다.  이는 역따옴표(`)를 사용하여 모든 리터럴을 포함할 수 있다. 

리터럴은 타입이 지정되어 있지 않다. 개발자가 특정 타입으로 지정하기 전까지는 강제하지 않는 것.

## 불리언
`bool` 타입은 불리언 변수를 의미한다. `true` 혹은 `false`를 갖는다. 
불리언 타입의 제로값은 `false`이다.

```go
var flag bool // 값을 지정하지않아, false 로 설정
var isAwesome = true
```

## 숫자 타입
Go에는 숫자타입이 다양하다. 세 가지 범주로 분류된 12개의 다른 타입이 있다.

### 정수 타입
|타입이름|값의범위|
|---|---|
|`int8`|1 바이트 부호있는 정수|
|`int16`|2 바이트 부호있는 정수|
|`int32`|4 바이트 부호있는 정수|
|`int64`|8 바이트 부호있는 정수|
|`uint8`|1 바이트 부호없는 정수, `byte`타입의 별칭|
|`uint16`|2 바이트 부호없는 정수|
|`uint32`|4 바이트 부호없는 정수|
|`uint64`|8 바이트 부호없는 정수|

### 특수 정수 타입
1. `byte` 타입은 `uint8` 타입의 별칭이다. 왠만해선 `byte` 타입을 쓰는게 좋다.
2. `int` 타입은 32비트 CPU에서 `int32`, 64비트 CPU에서 `int64`가 된다. 
   1. 플랫폼마다 일관되지 않아 환경이 바뀌면 오류가능성 존재. 
   2. 정수 리터럴은 기본적으로 `int` 타입을 사용한다.
3. `uint` 타입은 `int`와 동일한 규칙을 따르는데, 부호 없는 정수를 나타낸다.
4. `rune`, `uintptr` 도 존재한다.

### 사용할 정수 타입 선택
- 특정 크기를 갖거나 부호가 지정된 정수를 가진 네트워크 프로토콜이나 이진 파일 포맷을 가지고 작업하는 경우 해당되는 것 사용
- 모든 정수 타입을 처리하는 라이브러리 함수를 작성한다면 한 쌍의 함수를 만들어서 `int64`와 `uint64`를 갖는 함수의 쌍을 만든다.
- 위에서 언급된 경우를 제외하고는 `int`를 사용하기

### 정수 연산자
- Go 언어는 일반적인 상수 연산자를 지원한다. (+ - * / %)
- 나눗셈을 하게되면 0의 아래자리에서 잘린다. 
- `+=` `-=` `*=` `/=` `%=` 로 변수 수정이 가능하다.
- `==` `!=` `>` `>=` `<` `<=` 로 변수 비교가 가능하다.

## 부동소수 타입
- `float32`, `float64` 가 존재하며, 4바이트와 8바이트로 동작한다.
- float은 부정확하기 때문에 부정확한 값을 허용할 수 있는 상황이나, 부동소수점의 규칙을 잘 이해되는 상황에서만 사용한다.

## 복소수 타입
Go는 복소수 자료형을 지원한다.

1. `complex64` 자료형은 `float32`자료형을 가지고 실수부와 허수부를 각각 표현한다
2. `complex128` 자료형은 `float64`자료형을 가지고 실수부와 허수부를 각각 표현한다.

- 두 함수의 인자로 타입이 지정되지 않은 상수나 리터럴을 사용하면, 타입이 지정되지 않은 `complex` 리터럴을 만들고 기본타입은 `complex128`이 된다.
- `complex`로 전달하는 두 값을 `float32` 타입으로 했다면 `complex64`로 만들면 된다
- 실수부와 허수부를 뽑아내기 위해 각각 `imag`와 `real` 내장 함수를 제공한다.
- 여전히 부동소수점의 부정확성이 나타난다.

```go
func main() {
   x := complex(2.5, 3.1)
   y := complex(10.2, 2)
   fmt.Println(x + y)
   fmt.Println(real(x))
   fmt.Println(imag(x))
   fmt.Println(cmplx.Abs(x)) 
}
```

## 명시적 타입 변환
자동 타입 변환을 사용하면 한 타입을 다른 타입으로 적절하게 변환하는 규칙이 복잡해지고, 예기치 못한 결과를 발생시킬 수 있다.
의도의 명확성과 가독성의 중시하는 언어로서 Go는 변수들 간 자동 타입 변환을 허용하지 않는다.
서로다른 크기의 정수와 부동소수점 변수끼리도 타입변환은 필요하다.

```go
var x int = 10
var y float64 = 30.2
var z float64 = float64(x) + y
var d int = x + int(y)
```
