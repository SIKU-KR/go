## 배열

Go는 배열을 가지고있지만 직접 사용하는 경우는 드물다.

배열의 모든 요소는 지정된 타입이어야 한다. 몇 가지 배열 선언하는 방법이 있다.

1. 배열의 크기와 배열내의 요소 타입을 지정하는 방법이다.
```go
var x [3]int
```
이렇게 초기화하면 모든 요소는 제로값인 0으로 초기화된다.

2. 별도의 초기값을 설정하려면 배열 리터럴을 전달하면된다.
```go
var x = [3]int{10,20,30}
```

3. 다차원 배열은 다음과 같이 만들 수 있다.
```go
var x [2][3]int
```

4. 내장 함수 `len`을 사용하여 배열의 길이를 알 수 있다.
```go
fmt.Println(len(x))
```

## 슬라이스
일련의 값을 가지고있는 자료구조를 구성할 때 Go에서는 대부분 슬라이스를 사용한다.

슬라이스를 이렇게 유용하게 사용하는 이유는 슬라이스의 크기는 해당 타입의 일부가 아니기 때문이다.  (배열의 제약 제거)

1. 슬라이스를 선언할 때 슬라이스의 크기를 지정할 필요가 없다.
```go
var x = []int{10, 20, 30}
// 슬라이스 리터럴을 사용하여 3개의 정수를 가지는 슬라이스 생성
```

2. 2차원 슬라이스는 아래처럼 만든다
```go
var x [][]int
```

3. 대괄호를 사용하여 슬라이스의 읽기와 쓰기가 가능하고, 배열과 같이 크기를 넘어서거나 음수의 인덱스로는 접근이 불가능하다
```go
x[0] = 10
fmt.Println(x[2])
```

### 배열과 슬라이스의 차이점 : nil
```go
var x []int
```

이 코드는 정수 슬라이스를 생성한다. 

이때 어떠한 값도 할당되지 않았기 때문에 슬라이스를 위한 제로값이 할당되는데 이걸 `nil`이라고 부른다.

`nil`은 `null`과 다르게 몇몇타입의 값의 부재를 표현한 식별자이다.

두개의 슬라이스는 서로 `==` `!=` 연산자로 비교가 불가능하고, 오직 `nil`과 비교가 가능하다.

```go
fmt.Prinln(x == nil)
```

### `len()`
Go에서 슬라이스에 대한 몇가지 내장함수를 제공하는데, `len()` 함수는 슬라이스의 길이를 반환한다.

`nil` 슬라이스의 반환값은 0이다.

### `append()`
내장 함수 `append()`는 슬라이스에 새로운 요소를 추가한다.
```go
var x []int
x = append(x, 10)
```

또한 이미 요소가 있는 것에도 추가가 가능하며, 여러개의 값을 추가할 수도 있다.
```go
x = append(x, 5, 6, 7)
```

다른 하나의 슬라이스를 이용하여 슬라이스에 append도 가능하다.
```go
y := []int{20, 30, 40}
x = append(x, y, ...)
```

`append()` 함수를 통해 반환된 값을 할당하지 않는다면 컴파일 오류가 발생한다.

Go 언어는 Call by Value(값에 의한 호출) 방식을 사용하는 언어이기 때문에, 함수들이 복사본을 반환한다. 

### 수용력
슬라이스는 일련의 값을 저장한 것이다.

슬라이스의 각 용소는 연속적인 메모리 공간에 할당될 것이고, 이런 할당은 값을 빠르게 읽고 쓰기가 가능하도록한다. 

모든 슬라이스는 **수용력**을 가지는데 예약된 **연속적인 메모리 공간의 크기 값**을 가진다.

슬라이스가 수용 가능한 인덱스가 모두 찼을때, 새로운 메모리공간에 값을 복사하여 수용력을 확장하고 이전의 슬라이스는 가비지 컬렉션에 의해 회수된다. (**비싼 연산이 수행된다**)

내장함수 `len()`은 슬라이스의 현재 길이를 반환하고 `cap()`은 슬라이스를 수용력을 반환한다. 

따라서 수용력을 확인하여 값을 추가하는 구현도 `cap()`함수를 사용하면 가능할 수 있다.

> **GO 런타임**
>
> Go 런타임은 모든 Go 바이너리에 컴파일되어 포함된다. 이는 개발 언어로 작성된 프로그램을 수행하기 위해 반드시 따로 설치하는 가상머신을 이용하는 것과 차이가 있다. 바이너리에 런타임을 포함하는 것은 Go 프로그램의 배포를 쉽게하고, 런타임과 프로그램간의 호환성 이슈에 대해 걱정할 필요도 없다.

### `make()`
`make()` 함수는 타입, 길이, 선택적으로 수용력을 지정하여 슬라이스를 만들 수 있다.
```go
x := make([]int, 5)
// 길이 5, 수용력 5를 가지는 정수 슬라이스를 만듦
// 모든 값은 0으로 초기화 된다.
```
이렇게 만든 슬라이스에 `append()`함수로 삽입하면 첫번째 인덱스에 들어가는게 아니라, 슬라이스의 맨 끝에 들어간다.

예를들면,
```go
x := make([]int, 5)
x = append(x, 10)
// x = [0, 0, 0, 0, 0, 10]
```
`append()` 함수는 항상 슬라이스의 길이를 증가시키기 때문이다.

### 슬라이스 선언 스타일
슬라이스를 선언할 때 주된 목표는 슬라이스 내부적으로 확장되는 횟수를 최소화 해야한다.

- 슬라이스가 전혀 커질일이 없다면 `nil` 슬라이스를 만들기 위해 값의 할당이 없는 var 선언을 사용한다.
```go
var data []int
```

- 슬라이스가 시작 값을 가지거나 슬라이스 값이 변경되지 않는 경우라면 슬라이스 리터럴을 사용하여 선언하자.
```go
data := []int{2, 4, 6, 8}
```

- 슬라이스가 얼마나 커져야 하는지 잘 알고 있지만, 프로그램을 작성할 때 어떤 값인지 정확히 알 수 없다면 `make` 사용
  - 그럼 `make` 호출에 0이 아닌 길이를 지정해야 하는지 0이 아닌 길이를 지정해야하는지 생각해봐야한다.
  - 버퍼로 슬라이스를 사용한다면 0이아닌 길이로 지정
  - 원하는 크기를 정확히 알고 있다면, 슬라이스 길이와 인덱스를 지정하여 값을 설정
  - 이외의 상황에서는 0의길이와 지정된 수용력으로 `make`를 사용

### 슬라이스의 슬라이싱
슬라이스 연산자는 슬라이스에서 슬라이스를 만들게 한다.

대괄호 내에 콜론(:) 으로 구분하여 시작 오프셋과 마지막 오프셋으로 구성하여 사용한다.

```go
x := []int{1, 2, 3, 4}
y := x[:2]
z := x[1:]
d := x[1:3]
e := x[:]
```

### 슬라이스의 저장공간 공유
슬라이스에서 슬라이스를 가져왔을 때, 실제 데이터의 복사를 만들지는 않는다. 

대신 메모리를 공유하는 두개의 변수를 가지게 되는 것이다.

이러한 동작원리는 슬라이스와 `append()` 메서드가 같이 사용될 때 발생한다.

```go
x := []int{1, 2, 3, 4}
y := x[:2]
fmt.Println(cap(x), cap(y)) // 4 4
y = append(y, 30)
fmt.Println("x: ", x) // [1 2 30 4]
fmt.Println("y: ", y) // [1 2 30]
```

이런 복잡한 슬라이스 상황이 발생하지 않도록 하기위해, 하위슬라이스에 append를 사용하거나 append를 사용해도 덮어쓰기가 되지 않는 full slice expression을 사용하여야한다.

### `copy()`
원본 슬라이스로부터 독립적인 슬라이스를 생성할 필요가 있다면, `copy()`를 사용
```go
a := []int{1, 2, 3, 4, 5}
b := make([]int, 3) // make 함수로 공간을 할당

copy(b, a)     // 슬라이스 a의 요소를 슬라이스 b에 복사

fmt.Println(a) // [1 2 3 4 5]
fmt.Println(b) // [1 2 3]: 슬라이스 b의 길이는 3이므로 a의 요소 3개만 복사됨
```

